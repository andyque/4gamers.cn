#+TITLE: 三个 Git 问题(下)
#+DATE: 2015-09-21
#+SETUPFILE: ~/4gamers.cn/setupfile.org
#+JEKYLL_LAYOUT: post
#+JEKYLL_CATEGORIES: Git
#+JEKYLL_TAGS: Git 
#+JEKYLL_PUBLISHED: true

在上篇文章中，我们介绍了 Git 内部存储对象的方式，以及为什么不要用 Git 去管理大的二进制文件。

本文将继续探讨上篇文章中遗留的两个问题。

1. 如果两个 Branch 修改同一个文件的同一行代码，各自 Commit 一次，在 Merge 的时候为什么不会有冲突？

2. 同样是两个 Branch 修改同一个文件的同一行代码，各自 Commit 一次，在 Rebase 的时候为何有一个 Commit 会被优化掉？

{{{more}}}

* Merge 的测试代码
首先，我们新建一个分支，修改 a.txt，添加一行内容“Learn Git”：
#+BEGIN_SRC sh :dir testGit :exports code
git checkout -b testBranch
echo "Learn Git" >> a.txt
git commit -a -m 'commit'
#+END_SRC

此时，我们用 find 命令查看一下新增的 object 对象：

#+BEGIN_SRC sh :dir testGit :exports code
  find .git/objects -type f
#+END_SRC
[[http://guanghuiqu.qiniudn.com/2015-09-21-three-git-question-2_git-cat-file-1.png]]

这里我们可以看到多了 3 个对象：407b6e (commit),  49bf80 (modified a.txt) 和 81f485(tree object)。
我们可以用 git cat-file -p hash-code 来查看这 3 个对象的值。（注意这里我们使用的是 6 位数字的简码）

现在，让我们切回主分支，并且对主分支的 a.txt 做同样的修改：

#+BEGIN_SRC sh :dir testGit :exports code
git checkout master
echo "Learn Git" >> a.txt
git commit -a -m 'commit'
#+END_SRC

此时我们再查看一样新增的 object 对象：

#+BEGIN_SRC sh :dir testGit :exports code
  find .git/objects -type f
#+END_SRC
[[http://guanghuiqu.qiniudn.com/2015-09-21-three-git-question-2_git-cat-file-2.png]]

此时我们只新增了一个新的对象 9e2107(commit)，我们用 git cat-file 查看其值为：

#+BEGIN_SRC sh :dir testGit
  git cat-file -p 9e2107（如果这里换成 407b6e，结果是一样的）
#+END_SRC

[[http://guanghuiqu.qiniudn.com/2015-09-21-three-git-question-2_tree-object.png]]

此时，如果我们 merge testBranch 分支是不会有冲突的。

#+BEGIN_SRC sh :dir testGit :exports code
git merge testBranch
find .git/objects -type f
#+END_SRC
[[http://guanghuiqu.qiniudn.com/2015-09-21-three-git-question-2_cat-file-3.png]]

此时，我们发现多了一个 1bff79 对象，它的值如下：

#+BEGIN_SRC sh :dir testGit :exports code
git cat-file -p 1bff79
#+END_SRC
[[http://guanghuiqu.qiniudn.com/2015-09-21-three-git-question-2_tree-object-2.png]]

我们知道，整个过程中，我们在两个分支上分别对 a.txt 的同一行代码做了同样的修改，但是最终 git 只会保存一份 a.txt 的内容。
另外，整个目录树在不同的分支上面是一样的，所以 tree 对象也只有一份。

虽然我们在不同的分支上面做了两次 commit，但是这两次 commit 只是记录了各自的 tree，parent 以及作者等信息。

而在 merge 的时候，由于我们是 two-way merge，所以最终生成的 merge commit 是有两个 parent 的。

由上面的测试代码我们可以清楚地知道 merge 到底干了些什么事。

* Rebase 的测试代码

* 小结
