#+TITLE: 三个 Git 问题（上）
#+DATE: 2015-09-12
#+SETUPFILE: ~/4gamers.cn/setupfile.org
#+JEKYLL_LAYOUT: post
#+JEKYLL_CATEGORIES: Git
#+JEKYLL_TAGS: Git
#+JEKYLL_PUBLISHED: true

本系列文章主要回答三个 Git 问题:

1. 为什么不推荐用 Git 保存二进制大文件?

2. 如果两个 Branch 修改同一个文件的同一行代码，各自 Commit 一次,在 Merge 的时候为什么不会有冲突？

3. 同样是两个 Branch 修改同一个文件的同一行代码，各自 Commit 一次,在 Rebase 的时候为何有一个 Commit 会被优化掉？

{{{more}}}

要回答好这三个问题，我们需要理解 Git 的内部工作原理。

在保存文件历史的时候，Git 跟 SVN 最大的不一样在于，它保存的不是文件的 Diff 而是整个文件的快照。

* 什么是文件快照
#+BEGIN_SRC sh :cache yes
  mkdir testGit
  cd testGit
  echo "hello" >> a.txt
  echo "world" >> b.txt
  git init
  git add .
#+END_SRC

此时我们在 testGit 目录下面新建了一个 Git 仓库，并且新建了两个 txt 文件。此时我们可以在.git/objects 目录下面发现两个文件。
它们就是 a.txt 和 b.txt 的内容的压缩存储。


#+BEGIN_SRC sh :dir testGit :exports both
find .git/objects -type f
#+END_SRC

#+RESULTS:
 .git/objects/cc/628ccd10742baea8241c5924df992b5c019f71 
 .git/objects/ce/013625030ba8dba906f756967f9e9ca394464a 


a.txt 和 b.txt 的文件内容存储在 628ccd10742baea8241c5924df992b5c019f71 和 013625030ba8dba906f756967f9e9ca394464a 文件中。

但是 Git 是通过 hash 值来索引对象的，因此两个文件对应的 hash 值还需要加上文件夹的名称，即 cc628ccd10742baea8241c5924df992b5c019f71 和 ce013625030ba8dba906f756967f9e9ca394464a。

我们可以通过 git cat-file -p [hash value]来查看保存的对象的值：


#+BEGIN_SRC sh :dir testGit
  git cat-file -p cc628ccd10742baea8241c5924df992b5c019f71
  git cat-file -p ce013625030ba8dba906f756967f9e9ca394464a
#+END_SRC

#+RESULTS:
world b.txt
 hello a.txt

这里的 hash 值所代表的文件就是文件快照。此时，如果我们 commit 的话，会生成新的 hash 值对象。


#+BEGIN_SRC sh :dir testGit :exports both
  git commmit -m 'first commit'
  find .git/objects -type f
#+END_SRC

#+RESULTS:
 .git/objects/18/eb80fbbbf9160491c007668d5298f1e86cd40a 
 .git/objects/cc/628ccd10742baea8241c5924df992b5c019f71 
 .git/objects/ce/013625030ba8dba906f756967f9e9ca394464a 
 .git/objects/f6/042cce01150551255ec1e892d04b1c129a5fbd 


这里的 18eb80fbbbf9160491c007668d5298f1e86cd40a 和 f6042cce01150551255ec1e892d04b1c129a5fbd 是新生成的对象。

我们用 git cat-file -p 来看看它具体是什么？


#+BEGIN_SRC sh :dir testGit :exports both
  git cat-file -p 18eb80fbbbf9160491c007668d5298f1e86cd40a
#+END_SRC

#+RESULTS:
 100644 blob ce013625030ba8dba906f756967f9e9ca394464a  a.txt 
 100644 blob cc628ccd10742baea8241c5924df992b5c019f71  b.txt 



#+BEGIN_SRC sh :dir testGit :exports both
  git cat-file -p f6042cce01150551255ec1e892d04b1c129a5fbd
#+END_SRC

#+RESULTS:
| tree      | 18eb80fbbbf9160491c007668d5298f1e86cd40a |                        |
| author    | andyque                                  | <guanghui8827@126.com> |
| committer | andyque                                  | <guanghui8827@126.com> |
|           |                                          |                        |
| first     | commit                                   |                        |

这里的 18eb80fbbbf9160491c007668d5298f1e86cd40a 表示的是当前目录树的 hash 值，里面包含了每个文件的权限，类型，hash code 和名字信息。

而 f6042cce01150551255ec1e892d04b1c129a5fbd 则是我们的 commit 号，也就是平常我们用 git log 得到的内容。

如果此时我修改 a.txt 或者 b.txt，新修改后的文件会再用 zlib 压缩后生成一个 hash code 来当作名字。

而前后两个以 hash 值命名的文件的大小变化不大。但是如果是二进制大文件的话，每一次对该文件进行修改，它将会多占一份空间。

了解这一点非常重要。

* 为什么 Git 切换分支特别快？
因此要把版本的历史 checkout 到工作区，Git 只需要把使用 hash 值命名的文件解压缩就得到了。

如果是 svn，可能要找到一个参考版本，然后不断地应用 Diff 才来得到相应的分支。

* 为什么不推荐使用 Git 保存二进制大文件
由前面的解释，我们知道了 Git 使用的是文件快照来保存版本历史。但是二进制文件在压缩上几乎没有效果，所以，二进制文件只要有一点点修改，
保存的却是整个文件内容。

* 参考文献

- [[https://git-scm.com/book/en/v2/Git-Internals-Git-Objects][Git - Git Objects]]
