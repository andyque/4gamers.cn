#+TITLE: 优化 Cocos2d-x 游戏性能
#+DATE: 2016-07-24
#+SETUPFILE: ~/4gamers.cn/setupfile.org
#+JEKYLL_LAYOUT: post
#+JEKYLL_CATEGORIES: Cocos2d-x
#+JEKYLL_TAGS: Cocos2d-x
#+JEKYLL_PUBLISHED: true

这篇文章从理论的角度和大家一起来探讨一下如何优化 Cocos2d-x 游戏的性能，
这里面提供的优化技巧并不局限于使用 Cocos2d-x 引擎制作的游戏，也适用于其它任何引擎制作的游戏。

{{{more}}}

* Golden rules

** 查找游戏性能瓶颈，然后优化瓶颈
当我们在做任何性能优化之前，请牢记这条。造成你的系统性能瓶颈的代码通常只有那 20%的代码，切莫胡乱优化。

** 总是使用工具来查找性能瓶颈，而不是靠猜
目前社区里有许多工具可以用来查找图形应用的性能问题。

*** 查找 GPU 性能瓶颈的工具

1.  使用 Xcode OpenGL ES Profiler。

  文档链接地址： https://github.com/rstrahl/rudistrahl.me/blob/master/entries/Debugging-OpenGL-ES-With-Xcode-Profile-Tools.md

  这里是苹果官方的参考文档: https://developer.apple.com/library/ios/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/ToolsOverview/ToolsOverview.html

  如果你想 profiling 特定 GPU 的移动设备的图形性能，我们可以使用这些 GPU 制造商提供的工具：

2. 对于 ARM Mali GPU，可以使用 mali graphics debugger: http://malideveloper.arm.com/resources/tools/mali-graphics-debugger/
3. 对于 Imagination PowerVR GPU，可以使用 PVRTune: https://community.imgtec.com/developers/powervr/tools/pvrtune/
4. 对于 Qualcomm Adreno GPU，可以使用 adreno GPU profiler: https://developer.qualcomm.com/software/adreno-gpu-profiler

使用这些工具可以让你更清楚地知道你的图形渲染管线哪个阶段遇到瓶颈了，是顶点处理阶段，还是像素着色阶段。

=但是，请记住，一般你的游戏的性能问题可能并不在 GPU，而在 CPU=

*** 查找 CPU 性能瓶颈的工具

1. Mac 平台可以使用 Xcode 的 Time Profiler  工具：
   https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/MeasuringCPUUse.html

2. Windows 平台可以使用 Visual  Studio  的 CPU profiler：
   https://blogs.msdn.microsoft.com/visualstudioalm/2015/10/29/profile-your-cpu-in-the-debugger-in-visual-studio-2015/

3.  Cocos2d-html5 和 Cocos Creator 的用户，可以使用 Chrome（或者 Firefox） 自带的 timeline 工具和 CPU profile 工具。

**  熟悉你的移动设备和你使用的游戏引擎
熟悉你的移动设备使用的 GPU 和 CPU 的型号， Android 手机可以安装一个应用“GPU-Z”可以非常方便地查看到这些信息，而到目前为止iOS 设备统一使用的都是
PowerVR 的 GPU。如果你在测试游戏的过程中，发现其它手机都没有问题，但是某些具有同种类型的 GPU 的设备性能表现都不佳，此时你可能需要留意一下针对
特定 GPU 的优化技巧了。

同样的，了解你所使用的游戏引擎的局限也是非常重要的。你需要清楚地知道你所使用的游戏引擎是如何组织图形渲染命令的，这些命令又是如何处理 Batch Draw 的。
以及，我们需要如何组织我们的纹理和游戏节点对象，这样才能最大限度地利用引擎提供的自动批处理功能。

如果你知道这些内容，那么你就可以避免一些常见的性能瓶颈。


** 记住"足够好"原则
什么是“足够好“原则？
如果游戏玩家的眼睛不能区分不同质量的渲染结果，那么总是使用更省资源和计算更简单的实现方法。

我们都知道，一张像素格式为 RGBA4444 的图片在显示的时候，显示效果肯定是不如一张像素格式为 RGBA8888 的图片的。
但是，如果我们使用 RGBA4444 加上“抖动”算法，那么玩家一般是很难分辨出来的，特别是如果图片比较小，或者设备分辨率比较低的时候。

同样的原则也适用于声音，比如低采样率的声音比高采样率的声音更省内存和解码资源，如果玩家分辨不出差别，
那么也要选择更低采样率的声音资源，对于单通道和双通道声音也同理。


* Common Bottlenecks
按照经验来说，一般你的游戏的性能瓶颈都是出现在 CPU 而不是 GPU 上面。


** CPU  瓶颈通常跟 Draw call 数量和你的游戏循环的复杂度相关
所以，你需要尽可能地降低你的游戏的 Draw call 数量，最大限度地利用批次渲染来减少 Draw call 数量。
Cocos2d-x 3.x 包含了自动批处理功能，但是它需要你合图，并且生成的图形渲染命令必须相邻，且有相同的 material id。

对于游戏中出现的大量对象，比如子弹，鱼群等游戏对象，需要使用内存池技术来避免在游戏循环中产生大量的 IO 操作。
同时，对于游戏中需要用到的外部资源，比如纹理图集，声音文件和 TTF 文件等，尽量采用预先加载的方式来处理。

同时也千万要避免在游戏循环里面做非常复杂的计算，因为游戏循环每帧都会执行，所以这些耗时的操作很可能让你的游戏的 FPS大大降低。


** GPU 瓶颈通常局限于 Fillrate（Overdraw） 和 Bandwidth
如果你使用 Cocos2d-x 制作 2D 游戏，你一般不会编写复杂的 Shader，所以通常你不太会遇到 GPU 相关的性能问题。

但是，Overdraw 这个问题会导致你的 GPU 很容易碰到带宽的瓶颈，从而降低你的图形性能。所谓 Overdraw，指的是在图形渲染管线中，很多像素的着色对于最终
显示在屏幕上的颜色没有帮助，这些多余的计算和处理是浪费的，最重要的就是浪费带宽，因为它们需要从主存中采样纹理坐标。

尽管，现代的移动端 GPU 都有实现 TBDR（Tile-based Defered Rendering），但是只有 PowerVR的 HSR（隐藏表面剔除）可以极大地解决 Overdraw 的问题。
其它的 GPU 厂商都只实现了 TBDR + Early-Z，如果你按照从前往后的顺序提交不透明几何图元给 GPU 处理，那么这些 GPU 的 Overdraw 问题也会减少。

但是，我们知道 Cocos2d-x 引擎总是按照从后往前的顺序去提交图形渲染命令的，因为在 2D 里面，大量的图片都是带有透明像素的，为了保证 blending 的正确性，
就必须保持这种顺序的渲染命令提交。即使按照这种顺序去提交渲染命令，PowerVR 的 HSR 也可以在片断着色之前剔除掉不需要计算的像素。这也是为什么同样的 Cocos2d-x
游戏在很垃圾的 iPod 上面性能也不错，但是在某些 Android 旗舰机上面性能却表现得一团糟的原因。

注意: 通过使用工具， 预先将 2D 图片三角化，可以提高 Fillrate。

具体做法可以参考 TexturePacker 作者写的文章： https://www.codeandweb.com/texturepacker/tutorials/cocos2d-x-performance-optimization


* Simple checklist to make your Cocos2d-x game faster
1.  尽可能地使用批次渲染（Batch Draw）

2.  按照经验，尽可能把你的 Draw 数量控制在 50 以下

3.  减少 32 位未压缩纹理的使用，尽量使用 16 位且压缩过的纹理格式。

4.  尽可能地使用支持硬件解码的压缩纹理：比如 iOS 平台使用 PVRTC 纹理， 在安卓平台上面使用 ETC格式的纹理。
   目前所有的 Android 设备都是支持 ETC1 格式的纹理的，但是此纹理格式不支持 Alpha，所以你需要修改一下引擎以使用 ETC1 格式的纹理。

5.  不要使用系统字体来动态显示你的游戏中的分数等信息，请使用 BMFont 字体。

6.  请使用对象池和预加载技术来避免临时卡顿。

7. 使用 armeabi-v7a 架构来编译 Android 的 SO，因为在此架构下面 Cocos2d-x 会启用 neon 指令集，矩阵运算的效率会大大提高。

8. 不要使用动态光照，尽量使用 bake 光照。

9. 避免在 pixel shader 里面做非常复杂的计算

10. 避免在 pixel shader 里面使用 discard 和 alpha test，因为这样会破坏 GPU 自身的 depth testing 优化，比如 PowerVR 的 HSR。
